[
  {
    "mode": "generate_sql",
    "user_input": "Show all products with price less than $50",
    "assumptions": "1. The table name for storing product information is \"products\".\n2. The column name for storing product price is \"price\".\n3. The price column is of a numeric data type (e.g., decimal, integer, float).\n4. The database uses a dollar sign ($) to represent currency, but this will be ignored in the query as SQL typically uses numeric values for currency.",
    "sql_query": "SELECT * FROM products WHERE price < 50;"
  },
  {
    "mode": "generate_sql",
    "user_input": "Show monthly sales for the current year",
    "assumptions": "1. There is a table named \"sales\" that stores all sales data.\n2. The \"sales\" table has a column named \"sale_date\" of date type to store the date of each sale.\n3. The \"sales\" table has a column named \"amount\" to store the amount of each sale.\n4. The database management system being used is capable of handling date functions, such as extracting the year and month from a date.\n5. The current year is the year of the system's current date.",
    "sql_query": "SELECT EXTRACT(MONTH FROM sale_date) AS month, SUM(amount) AS total_sales \nFROM sales \nWHERE EXTRACT(YEAR FROM sale_date) = EXTRACT(YEAR FROM CURRENT_DATE) \nGROUP BY EXTRACT(MONTH FROM sale_date) \nORDER BY month;"
  },
  {
    "mode": "generate_sql",
    "user_input": "List employees along with their manager names",
    "assumptions": "1. There is a table named \"employees\" that stores information about all employees.\n2. The \"employees\" table has columns named \"employee_id\", \"name\", and \"manager_id\" to store the employee's ID, name, and manager's ID respectively.\n3. The \"manager_id\" in the \"employees\" table refers to the \"employee_id\" of the manager, allowing for self-referential relationships.\n4. The manager of an employee is also an employee in the same table.",
    "sql_query": "SELECT e1.name AS employee_name, e2.name AS manager_name \nFROM employees e1 \nLEFT JOIN employees e2 \nON e1.manager_id = e2.employee_id;"
  },
  {
    "mode": "generate_sql",
    "user_input": "Calculate average order value by customer segment",
    "assumptions": "1. There is a table named \"orders\" that contains information about each order, including the order total and customer ID.\n2. There is a table named \"customers\" that contains information about each customer, including the customer ID and segment.\n3. The \"orders\" table has a column named \"order_total\" that represents the total value of each order.\n4. The \"customers\" table has a column named \"customer_id\" that uniquely identifies each customer.\n5. The \"customers\" table has a column named \"segment\" that represents the customer segment.\n6. The \"orders\" table has a column named \"customer_id\" that references the \"customer_id\" column in the \"customers\" table.",
    "sql_query": "SELECT c.segment, AVG(o.order_total) AS average_order_value \nFROM orders o \nJOIN customers c ON o.customer_id = c.customer_id \nGROUP BY c.segment;"
  },
  {
    "mode": "generate_sql",
    "user_input": "Show customer retention rate month over month",
    "assumptions": "1. There is a table named \"customers\" that stores information about each customer, including a unique customer ID and the date they first made a purchase.\n2. There is a table named \"orders\" that stores information about each order, including the customer ID, order date, and order total.\n3. The customer retention rate is calculated as the percentage of customers who made a purchase in the current month and also made a purchase in the previous month.\n4. The database management system being used is capable of handling date and time functions, such as extracting the month and year from a date.",
    "sql_query": "```sql\nWITH \n  -- Get the number of customers who made a purchase in each month\n  monthly_customers AS (\n    SELECT \n      EXTRACT(YEAR FROM o.order_date) AS year,\n      EXTRACT(MONTH FROM o.order_date) AS month,\n      c.customer_id\n    FROM \n      customers c\n    JOIN \n      orders o ON c.customer_id = o.customer_id\n  ),\n  \n  -- Get the number of customers who made a purchase in the current and previous months\n  retained_customers AS (\n    SELECT \n      mc1.year,\n      mc1.month,\n      COUNT(DISTINCT mc1.customer_id) AS retained_count\n    FROM \n      monthly_customers mc1\n    JOIN \n      monthly_customers mc2 ON mc1.customer_id = mc2.customer_id\n      AND mc2.month = mc1.month - 1\n      AND mc2.year = mc1.year\n    GROUP BY \n      mc1.year, mc1.month\n  ),\n  \n  -- Get the total number of customers who made a purchase in each month\n  total_customers AS (\n    SELECT \n      year,\n      month,\n      COUNT(DISTINCT customer_id) AS total_count\n    FROM \n      monthly_customers\n    GROUP BY \n      year, month\n  )\n\nSELECT \n  rc.year,\n  rc.month,\n  (rc.retained_count * 1.0 / tc.total_count) * 100 AS retention_rate\nFROM \n  retained_customers rc\nJOIN \n  total_customers tc ON rc.year = tc.year AND rc.month = tc.month\nORDER BY \n  rc.year, rc.month;\n```;"
  },
  {
    "mode": "explain_sql",
    "user_input": "SELECT name, email FROM users WHERE active = true;",
    "output": "Here's the explanation of the SQL query:\n\n1. **Query Intent**:\nThe intent of this query is to retrieve the names and email addresses of active users from the users table.\n\n2. **Tables Involved**:\n- users: This table is expected to store information about users, including their names, email addresses, and activation status.\n\n3. **Keyword / Clause Explanation**:\n- **SELECT**: This keyword specifies which columns should be retrieved from the table. In this case, it's selecting two columns: `name` and `email`.\n- **name** and **email**: These are the columns being requested; they represent the user's name and email address, respectively.\n- **FROM**: This keyword specifies the table from which the data should be fetched.\n- **users**: This is the table that contains the requested columns.\n- **WHERE**: This keyword is used to filter the data based on a condition. It specifies that only rows that meet the condition should be included in the result set.\n- **active = true**: This is the condition being applied to filter the data. It means that only rows where the `active` column has a value of `true` will be included in the result set. The `active` column likely represents a boolean value indicating whether a user's account is active or not.\n\n4. **Final Result Description**:\nThe query will return a list of names and email addresses of users who have an active account (i.e., where `active` is `true`). The result set will contain two columns: `name` and `email`, with each row representing an active user."
  },
  {
    "mode": "explain_sql",
    "user_input": "SELECT COUNT(*) as total_users FROM customers;",
    "output": "Here's the explanation of the SQL query:\n\n1. Query Intent:\nThe intent of this query is to count the total number of rows (or records) in the customers table, effectively giving the total number of customers.\n\n2. Tables Involved:\n- customers: This table is expected to store information about each customer.\n\n3. Keyword / Clause Explanation:\n- SELECT: This keyword specifies which columns or data should be retrieved from the table. In this case, it's not a specific column but a function.\n- COUNT(*): This is an aggregate function that counts the number of rows in the table. The asterisk (*) is a wildcard character that represents all columns. Since we're counting rows and not specific values, the actual columns don't matter.\n- as total_users: This is an alias. It gives a temporary name to the result of the COUNT(*) function, making it easier to reference in the output. Here, the count of rows is aliased as \"total_users\".\n- FROM: This keyword specifies the table from which the data should be fetched.\n- customers: This is the table that contains the data to be counted.\n\n4. Final Result Description:\nThe query will return a single value representing the total number of rows in the customers table, labeled as \"total_users\". This value gives an overview of how many customer records exist in the database."
  },
  {
    "mode": "explain_sql",
    "user_input": "SELECT \n    department,\n    COUNT(*) as emp_count,\n    AVG(salary) as avg_salary\nFROM employees\nWHERE hire_date > '2020-01-01'\nGROUP BY department\nHAVING COUNT(*) > 5;",
    "output": "### Query Intent\nThe intent of this query is to retrieve the department names, the number of employees in each department, and the average salary of employees in each department, but only for departments that have more than 5 employees hired after January 1, 2020.\n\n### Tables Involved\n- employees: This table is expected to store information about employees, including their department, hire date, and salary.\n\n### Keyword / Clause Explanation\n- **SELECT**: This keyword specifies which columns or calculations should be retrieved from the table.\n  - **department**: This column represents the department name of each employee.\n  - **COUNT(\\*) as emp_count**: This counts the total number of rows (i.e., employees) in each group (department) and assigns the result to an alias named **emp_count**.\n  - **AVG(salary) as avg_salary**: This calculates the average salary of employees in each group (department) and assigns the result to an alias named **avg_salary**.\n- **FROM**: This keyword specifies the table from which the data should be fetched.\n  - **employees**: This is the table that contains the requested columns.\n- **WHERE**: This keyword filters the rows to only include those that meet the specified condition.\n  - **hire_date > '2020-01-01'**: This condition ensures that only employees hired after January 1, 2020, are included in the query results.\n- **GROUP BY**: This keyword groups the remaining rows (after filtering) by one or more columns.\n  - **department**: This groups the employees by their department, allowing for calculations (like COUNT and AVG) to be performed separately for each department.\n- **HAVING**: This keyword filters the groups (not individual rows) based on conditions applied to the grouped data.\n  - **COUNT(\\*) > 5**: This condition ensures that only departments with more than 5 employees (hired after January 1, 2020) are included in the final results.\n\n### Final Result Description\nThe query will return a list of department names, along with the number of employees in each department (who were hired after January 1, 2020) and the average salary of those employees, but only for departments that have more than 5 such employees. The results will be grouped by department, providing a summary of employee count and average salary for each qualifying department."
  },
  {
    "mode": "explain_sql",
    "user_input": "SELECT \n    e.employee_id,\n    e.name,\n    e.department,\n    e.salary,\n    (SELECT AVG(salary) FROM employees WHERE department = e.department) as dept_avg_salary\nFROM employees e\nWHERE e.salary > (SELECT AVG(salary) FROM employees)\nORDER BY e.salary DESC;",
    "output": "### Query Intent\nThe intent of this query is to retrieve a list of employees with their respective details, including their department and salary, along with the average salary of their department. The query also filters employees based on their salary being higher than the overall average salary across all departments and orders the results by salary in descending order.\n\n### Tables Involved\n- employees (aliased as `e`): This table is expected to store employee-related information, including employee_id, name, department, and salary.\n\n### Keyword / Clause Explanation\n- **SELECT**: This keyword specifies which columns should be retrieved from the table. In this query, it selects `employee_id`, `name`, `department`, and `salary` from the `employees` table.\n- **e.employee_id, e.name, e.department, e.salary**: These are the columns being requested. The `e` is an alias for the `employees` table, making it easier to refer to the table in other parts of the query.\n- **(SELECT AVG(salary) FROM employees WHERE department = e.department) as dept_avg_salary**: This is a subquery that calculates the average salary of the department to which each employee belongs. It uses the `AVG` function to calculate the average and filters the results to only include employees in the same department as the current employee (`e.department`). The result is given an alias `dept_avg_salary`.\n- **FROM employees e**: This specifies the table from which the data should be fetched, which is `employees`. The `e` is an alias for `employees`, used for brevity and clarity in the query.\n- **WHERE e.salary > (SELECT AVG(salary) FROM employees)**: This clause filters the results to only include employees whose salary is greater than the overall average salary across all departments. The subquery `(SELECT AVG(salary) FROM employees)` calculates this overall average salary.\n- **ORDER BY e.salary DESC**: This clause sorts the results in descending order based on the `salary` column. Employees with the highest salaries will appear at the top of the list.\n\n### Final Result Description\nThe query will return a list of employees who earn more than the overall average salary, including their `employee_id`, `name`, `department`, `salary`, and the average salary of their department (`dept_avg_salary`). The list will be ordered by salary in descending order, with the highest-paid employees first. This allows for easy identification of high-earning employees and comparison of their salaries to the average salary within their respective departments."
  }
]